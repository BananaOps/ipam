// @generated by protobuf-ts 2.11.1 with parameter generate_dependencies
// @generated from protobuf file "subnet.proto" (package "ipam", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * Subnet represents a network subnet with all its properties
 *
 * @generated from protobuf message ipam.Subnet
 */
export interface Subnet {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string cidr = 2
     */
    cidr: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * @generated from protobuf field: string location = 5
     */
    location: string;
    /**
     * @generated from protobuf field: ipam.LocationType location_type = 6
     */
    locationType: LocationType;
    /**
     * @generated from protobuf field: ipam.CloudInfo cloud_info = 7
     */
    cloudInfo?: CloudInfo;
    /**
     * @generated from protobuf field: ipam.SubnetDetails details = 8
     */
    details?: SubnetDetails;
    /**
     * @generated from protobuf field: ipam.UtilizationInfo utilization = 9
     */
    utilization?: UtilizationInfo;
    /**
     * @generated from protobuf field: int64 created_at = 10
     */
    createdAt: bigint;
    /**
     * @generated from protobuf field: int64 updated_at = 11
     */
    updatedAt: bigint;
}
/**
 * CloudInfo contains cloud provider specific information
 *
 * @generated from protobuf message ipam.CloudInfo
 */
export interface CloudInfo {
    /**
     * @generated from protobuf field: string provider = 1
     */
    provider: string;
    /**
     * @generated from protobuf field: string region = 2
     */
    region: string;
    /**
     * @generated from protobuf field: string account_id = 3
     */
    accountId: string;
}
/**
 * SubnetDetails contains calculated subnet properties
 *
 * @generated from protobuf message ipam.SubnetDetails
 */
export interface SubnetDetails {
    /**
     * @generated from protobuf field: string address = 1
     */
    address: string;
    /**
     * @generated from protobuf field: string netmask = 2
     */
    netmask: string;
    /**
     * @generated from protobuf field: string wildcard = 3
     */
    wildcard: string;
    /**
     * @generated from protobuf field: string network = 4
     */
    network: string;
    /**
     * @generated from protobuf field: string type = 5
     */
    type: string;
    /**
     * @generated from protobuf field: string broadcast = 6
     */
    broadcast: string;
    /**
     * @generated from protobuf field: string host_min = 7
     */
    hostMin: string;
    /**
     * @generated from protobuf field: string host_max = 8
     */
    hostMax: string;
    /**
     * @generated from protobuf field: int32 hosts_per_net = 9
     */
    hostsPerNet: number;
    /**
     * @generated from protobuf field: bool is_public = 10
     */
    isPublic: boolean;
}
/**
 * UtilizationInfo tracks IP address usage
 *
 * @generated from protobuf message ipam.UtilizationInfo
 */
export interface UtilizationInfo {
    /**
     * @generated from protobuf field: int32 total_ips = 1
     */
    totalIps: number;
    /**
     * @generated from protobuf field: int32 allocated_ips = 2
     */
    allocatedIps: number;
    /**
     * @generated from protobuf field: float utilization_percent = 3
     */
    utilizationPercent: number;
}
/**
 * CreateSubnetRequest is used to create a new subnet
 *
 * @generated from protobuf message ipam.CreateSubnetRequest
 */
export interface CreateSubnetRequest {
    /**
     * @generated from protobuf field: string cidr = 1
     */
    cidr: string;
    /**
     * @generated from protobuf field: string name = 2
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 3
     */
    description: string;
    /**
     * @generated from protobuf field: string location = 4
     */
    location: string;
    /**
     * @generated from protobuf field: ipam.LocationType location_type = 5
     */
    locationType: LocationType;
    /**
     * @generated from protobuf field: ipam.CloudInfo cloud_info = 6
     */
    cloudInfo?: CloudInfo;
}
/**
 * CreateSubnetResponse returns the created subnet or error
 *
 * @generated from protobuf message ipam.CreateSubnetResponse
 */
export interface CreateSubnetResponse {
    /**
     * @generated from protobuf field: ipam.Subnet subnet = 1
     */
    subnet?: Subnet;
    /**
     * @generated from protobuf field: ipam.Error error = 2
     */
    error?: Error;
}
/**
 * ListSubnetsRequest is used to query subnets with filters
 *
 * @generated from protobuf message ipam.ListSubnetsRequest
 */
export interface ListSubnetsRequest {
    /**
     * @generated from protobuf field: string location_filter = 1
     */
    locationFilter: string;
    /**
     * @generated from protobuf field: string cloud_provider_filter = 2
     */
    cloudProviderFilter: string;
    /**
     * @generated from protobuf field: string search_query = 3
     */
    searchQuery: string;
    /**
     * @generated from protobuf field: int32 page = 4
     */
    page: number;
    /**
     * @generated from protobuf field: int32 page_size = 5
     */
    pageSize: number;
}
/**
 * ListSubnetsResponse returns a list of subnets
 *
 * @generated from protobuf message ipam.ListSubnetsResponse
 */
export interface ListSubnetsResponse {
    /**
     * @generated from protobuf field: repeated ipam.Subnet subnets = 1
     */
    subnets: Subnet[];
    /**
     * @generated from protobuf field: int32 total_count = 2
     */
    totalCount: number;
    /**
     * @generated from protobuf field: ipam.Error error = 3
     */
    error?: Error;
}
/**
 * GetSubnetRequest is used to retrieve a specific subnet
 *
 * @generated from protobuf message ipam.GetSubnetRequest
 */
export interface GetSubnetRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * GetSubnetResponse returns the requested subnet or error
 *
 * @generated from protobuf message ipam.GetSubnetResponse
 */
export interface GetSubnetResponse {
    /**
     * @generated from protobuf field: ipam.Subnet subnet = 1
     */
    subnet?: Subnet;
    /**
     * @generated from protobuf field: ipam.Error error = 2
     */
    error?: Error;
}
/**
 * UpdateSubnetRequest is used to update an existing subnet
 *
 * @generated from protobuf message ipam.UpdateSubnetRequest
 */
export interface UpdateSubnetRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
    /**
     * @generated from protobuf field: string cidr = 2
     */
    cidr: string;
    /**
     * @generated from protobuf field: string name = 3
     */
    name: string;
    /**
     * @generated from protobuf field: string description = 4
     */
    description: string;
    /**
     * @generated from protobuf field: string location = 5
     */
    location: string;
    /**
     * @generated from protobuf field: ipam.LocationType location_type = 6
     */
    locationType: LocationType;
    /**
     * @generated from protobuf field: ipam.CloudInfo cloud_info = 7
     */
    cloudInfo?: CloudInfo;
}
/**
 * UpdateSubnetResponse returns the updated subnet or error
 *
 * @generated from protobuf message ipam.UpdateSubnetResponse
 */
export interface UpdateSubnetResponse {
    /**
     * @generated from protobuf field: ipam.Subnet subnet = 1
     */
    subnet?: Subnet;
    /**
     * @generated from protobuf field: ipam.Error error = 2
     */
    error?: Error;
}
/**
 * DeleteSubnetRequest is used to delete a subnet
 *
 * @generated from protobuf message ipam.DeleteSubnetRequest
 */
export interface DeleteSubnetRequest {
    /**
     * @generated from protobuf field: string id = 1
     */
    id: string;
}
/**
 * DeleteSubnetResponse confirms deletion or returns error
 *
 * @generated from protobuf message ipam.DeleteSubnetResponse
 */
export interface DeleteSubnetResponse {
    /**
     * @generated from protobuf field: bool success = 1
     */
    success: boolean;
    /**
     * @generated from protobuf field: ipam.Error error = 2
     */
    error?: Error;
}
/**
 * Error represents a structured error response
 *
 * @generated from protobuf message ipam.Error
 */
export interface Error {
    /**
     * @generated from protobuf field: string code = 1
     */
    code: string;
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string;
    /**
     * @generated from protobuf field: map<string, string> details = 3
     */
    details: {
        [key: string]: string;
    };
    /**
     * @generated from protobuf field: int64 timestamp = 4
     */
    timestamp: bigint;
}
/**
 * LocationType defines where the subnet is located
 *
 * @generated from protobuf enum ipam.LocationType
 */
export enum LocationType {
    /**
     * @generated from protobuf enum value: DATACENTER = 0;
     */
    DATACENTER = 0,
    /**
     * @generated from protobuf enum value: SITE = 1;
     */
    SITE = 1,
    /**
     * @generated from protobuf enum value: CLOUD = 2;
     */
    CLOUD = 2
}
// @generated message type with reflection information, may provide speed optimized methods
class Subnet$Type extends MessageType<Subnet> {
    constructor() {
        super("ipam.Subnet", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cidr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "location_type", kind: "enum", T: () => ["ipam.LocationType", LocationType] },
            { no: 7, name: "cloud_info", kind: "message", T: () => CloudInfo },
            { no: 8, name: "details", kind: "message", T: () => SubnetDetails },
            { no: 9, name: "utilization", kind: "message", T: () => UtilizationInfo },
            { no: 10, name: "created_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ },
            { no: 11, name: "updated_at", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Subnet>): Subnet {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.cidr = "";
        message.name = "";
        message.description = "";
        message.location = "";
        message.locationType = 0;
        message.createdAt = 0n;
        message.updatedAt = 0n;
        if (value !== undefined)
            reflectionMergePartial<Subnet>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Subnet): Subnet {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string cidr */ 2:
                    message.cidr = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* string location */ 5:
                    message.location = reader.string();
                    break;
                case /* ipam.LocationType location_type */ 6:
                    message.locationType = reader.int32();
                    break;
                case /* ipam.CloudInfo cloud_info */ 7:
                    message.cloudInfo = CloudInfo.internalBinaryRead(reader, reader.uint32(), options, message.cloudInfo);
                    break;
                case /* ipam.SubnetDetails details */ 8:
                    message.details = SubnetDetails.internalBinaryRead(reader, reader.uint32(), options, message.details);
                    break;
                case /* ipam.UtilizationInfo utilization */ 9:
                    message.utilization = UtilizationInfo.internalBinaryRead(reader, reader.uint32(), options, message.utilization);
                    break;
                case /* int64 created_at */ 10:
                    message.createdAt = reader.int64().toBigInt();
                    break;
                case /* int64 updated_at */ 11:
                    message.updatedAt = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Subnet, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string cidr = 2; */
        if (message.cidr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cidr);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* string location = 5; */
        if (message.location !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.location);
        /* ipam.LocationType location_type = 6; */
        if (message.locationType !== 0)
            writer.tag(6, WireType.Varint).int32(message.locationType);
        /* ipam.CloudInfo cloud_info = 7; */
        if (message.cloudInfo)
            CloudInfo.internalBinaryWrite(message.cloudInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* ipam.SubnetDetails details = 8; */
        if (message.details)
            SubnetDetails.internalBinaryWrite(message.details, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* ipam.UtilizationInfo utilization = 9; */
        if (message.utilization)
            UtilizationInfo.internalBinaryWrite(message.utilization, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        /* int64 created_at = 10; */
        if (message.createdAt !== 0n)
            writer.tag(10, WireType.Varint).int64(message.createdAt);
        /* int64 updated_at = 11; */
        if (message.updatedAt !== 0n)
            writer.tag(11, WireType.Varint).int64(message.updatedAt);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.Subnet
 */
export const Subnet = new Subnet$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CloudInfo$Type extends MessageType<CloudInfo> {
    constructor() {
        super("ipam.CloudInfo", [
            { no: 1, name: "provider", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "region", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "account_id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CloudInfo>): CloudInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.provider = "";
        message.region = "";
        message.accountId = "";
        if (value !== undefined)
            reflectionMergePartial<CloudInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CloudInfo): CloudInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string provider */ 1:
                    message.provider = reader.string();
                    break;
                case /* string region */ 2:
                    message.region = reader.string();
                    break;
                case /* string account_id */ 3:
                    message.accountId = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CloudInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string provider = 1; */
        if (message.provider !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.provider);
        /* string region = 2; */
        if (message.region !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.region);
        /* string account_id = 3; */
        if (message.accountId !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.accountId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.CloudInfo
 */
export const CloudInfo = new CloudInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SubnetDetails$Type extends MessageType<SubnetDetails> {
    constructor() {
        super("ipam.SubnetDetails", [
            { no: 1, name: "address", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "netmask", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "wildcard", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "network", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "type", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "broadcast", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 7, name: "host_min", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 8, name: "host_max", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 9, name: "hosts_per_net", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 10, name: "is_public", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SubnetDetails>): SubnetDetails {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.address = "";
        message.netmask = "";
        message.wildcard = "";
        message.network = "";
        message.type = "";
        message.broadcast = "";
        message.hostMin = "";
        message.hostMax = "";
        message.hostsPerNet = 0;
        message.isPublic = false;
        if (value !== undefined)
            reflectionMergePartial<SubnetDetails>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SubnetDetails): SubnetDetails {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string address */ 1:
                    message.address = reader.string();
                    break;
                case /* string netmask */ 2:
                    message.netmask = reader.string();
                    break;
                case /* string wildcard */ 3:
                    message.wildcard = reader.string();
                    break;
                case /* string network */ 4:
                    message.network = reader.string();
                    break;
                case /* string type */ 5:
                    message.type = reader.string();
                    break;
                case /* string broadcast */ 6:
                    message.broadcast = reader.string();
                    break;
                case /* string host_min */ 7:
                    message.hostMin = reader.string();
                    break;
                case /* string host_max */ 8:
                    message.hostMax = reader.string();
                    break;
                case /* int32 hosts_per_net */ 9:
                    message.hostsPerNet = reader.int32();
                    break;
                case /* bool is_public */ 10:
                    message.isPublic = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SubnetDetails, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string address = 1; */
        if (message.address !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.address);
        /* string netmask = 2; */
        if (message.netmask !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.netmask);
        /* string wildcard = 3; */
        if (message.wildcard !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.wildcard);
        /* string network = 4; */
        if (message.network !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.network);
        /* string type = 5; */
        if (message.type !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.type);
        /* string broadcast = 6; */
        if (message.broadcast !== "")
            writer.tag(6, WireType.LengthDelimited).string(message.broadcast);
        /* string host_min = 7; */
        if (message.hostMin !== "")
            writer.tag(7, WireType.LengthDelimited).string(message.hostMin);
        /* string host_max = 8; */
        if (message.hostMax !== "")
            writer.tag(8, WireType.LengthDelimited).string(message.hostMax);
        /* int32 hosts_per_net = 9; */
        if (message.hostsPerNet !== 0)
            writer.tag(9, WireType.Varint).int32(message.hostsPerNet);
        /* bool is_public = 10; */
        if (message.isPublic !== false)
            writer.tag(10, WireType.Varint).bool(message.isPublic);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.SubnetDetails
 */
export const SubnetDetails = new SubnetDetails$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UtilizationInfo$Type extends MessageType<UtilizationInfo> {
    constructor() {
        super("ipam.UtilizationInfo", [
            { no: 1, name: "total_ips", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "allocated_ips", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "utilization_percent", kind: "scalar", T: 2 /*ScalarType.FLOAT*/ }
        ]);
    }
    create(value?: PartialMessage<UtilizationInfo>): UtilizationInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.totalIps = 0;
        message.allocatedIps = 0;
        message.utilizationPercent = 0;
        if (value !== undefined)
            reflectionMergePartial<UtilizationInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UtilizationInfo): UtilizationInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 total_ips */ 1:
                    message.totalIps = reader.int32();
                    break;
                case /* int32 allocated_ips */ 2:
                    message.allocatedIps = reader.int32();
                    break;
                case /* float utilization_percent */ 3:
                    message.utilizationPercent = reader.float();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UtilizationInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 total_ips = 1; */
        if (message.totalIps !== 0)
            writer.tag(1, WireType.Varint).int32(message.totalIps);
        /* int32 allocated_ips = 2; */
        if (message.allocatedIps !== 0)
            writer.tag(2, WireType.Varint).int32(message.allocatedIps);
        /* float utilization_percent = 3; */
        if (message.utilizationPercent !== 0)
            writer.tag(3, WireType.Bit32).float(message.utilizationPercent);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.UtilizationInfo
 */
export const UtilizationInfo = new UtilizationInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSubnetRequest$Type extends MessageType<CreateSubnetRequest> {
    constructor() {
        super("ipam.CreateSubnetRequest", [
            { no: 1, name: "cidr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "location_type", kind: "enum", T: () => ["ipam.LocationType", LocationType] },
            { no: 6, name: "cloud_info", kind: "message", T: () => CloudInfo }
        ]);
    }
    create(value?: PartialMessage<CreateSubnetRequest>): CreateSubnetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.cidr = "";
        message.name = "";
        message.description = "";
        message.location = "";
        message.locationType = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateSubnetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSubnetRequest): CreateSubnetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string cidr */ 1:
                    message.cidr = reader.string();
                    break;
                case /* string name */ 2:
                    message.name = reader.string();
                    break;
                case /* string description */ 3:
                    message.description = reader.string();
                    break;
                case /* string location */ 4:
                    message.location = reader.string();
                    break;
                case /* ipam.LocationType location_type */ 5:
                    message.locationType = reader.int32();
                    break;
                case /* ipam.CloudInfo cloud_info */ 6:
                    message.cloudInfo = CloudInfo.internalBinaryRead(reader, reader.uint32(), options, message.cloudInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSubnetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string cidr = 1; */
        if (message.cidr !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.cidr);
        /* string name = 2; */
        if (message.name !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.name);
        /* string description = 3; */
        if (message.description !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.description);
        /* string location = 4; */
        if (message.location !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.location);
        /* ipam.LocationType location_type = 5; */
        if (message.locationType !== 0)
            writer.tag(5, WireType.Varint).int32(message.locationType);
        /* ipam.CloudInfo cloud_info = 6; */
        if (message.cloudInfo)
            CloudInfo.internalBinaryWrite(message.cloudInfo, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.CreateSubnetRequest
 */
export const CreateSubnetRequest = new CreateSubnetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateSubnetResponse$Type extends MessageType<CreateSubnetResponse> {
    constructor() {
        super("ipam.CreateSubnetResponse", [
            { no: 1, name: "subnet", kind: "message", T: () => Subnet },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<CreateSubnetResponse>): CreateSubnetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<CreateSubnetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateSubnetResponse): CreateSubnetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ipam.Subnet subnet */ 1:
                    message.subnet = Subnet.internalBinaryRead(reader, reader.uint32(), options, message.subnet);
                    break;
                case /* ipam.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateSubnetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ipam.Subnet subnet = 1; */
        if (message.subnet)
            Subnet.internalBinaryWrite(message.subnet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ipam.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.CreateSubnetResponse
 */
export const CreateSubnetResponse = new CreateSubnetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSubnetsRequest$Type extends MessageType<ListSubnetsRequest> {
    constructor() {
        super("ipam.ListSubnetsRequest", [
            { no: 1, name: "location_filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cloud_provider_filter", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "search_query", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "page", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "page_size", kind: "scalar", T: 5 /*ScalarType.INT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListSubnetsRequest>): ListSubnetsRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.locationFilter = "";
        message.cloudProviderFilter = "";
        message.searchQuery = "";
        message.page = 0;
        message.pageSize = 0;
        if (value !== undefined)
            reflectionMergePartial<ListSubnetsRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSubnetsRequest): ListSubnetsRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string location_filter */ 1:
                    message.locationFilter = reader.string();
                    break;
                case /* string cloud_provider_filter */ 2:
                    message.cloudProviderFilter = reader.string();
                    break;
                case /* string search_query */ 3:
                    message.searchQuery = reader.string();
                    break;
                case /* int32 page */ 4:
                    message.page = reader.int32();
                    break;
                case /* int32 page_size */ 5:
                    message.pageSize = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSubnetsRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string location_filter = 1; */
        if (message.locationFilter !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.locationFilter);
        /* string cloud_provider_filter = 2; */
        if (message.cloudProviderFilter !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cloudProviderFilter);
        /* string search_query = 3; */
        if (message.searchQuery !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.searchQuery);
        /* int32 page = 4; */
        if (message.page !== 0)
            writer.tag(4, WireType.Varint).int32(message.page);
        /* int32 page_size = 5; */
        if (message.pageSize !== 0)
            writer.tag(5, WireType.Varint).int32(message.pageSize);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.ListSubnetsRequest
 */
export const ListSubnetsRequest = new ListSubnetsRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ListSubnetsResponse$Type extends MessageType<ListSubnetsResponse> {
    constructor() {
        super("ipam.ListSubnetsResponse", [
            { no: 1, name: "subnets", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => Subnet },
            { no: 2, name: "total_count", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 3, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<ListSubnetsResponse>): ListSubnetsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.subnets = [];
        message.totalCount = 0;
        if (value !== undefined)
            reflectionMergePartial<ListSubnetsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListSubnetsResponse): ListSubnetsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated ipam.Subnet subnets */ 1:
                    message.subnets.push(Subnet.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* int32 total_count */ 2:
                    message.totalCount = reader.int32();
                    break;
                case /* ipam.Error error */ 3:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListSubnetsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated ipam.Subnet subnets = 1; */
        for (let i = 0; i < message.subnets.length; i++)
            Subnet.internalBinaryWrite(message.subnets[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* int32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).int32(message.totalCount);
        /* ipam.Error error = 3; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.ListSubnetsResponse
 */
export const ListSubnetsResponse = new ListSubnetsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubnetRequest$Type extends MessageType<GetSubnetRequest> {
    constructor() {
        super("ipam.GetSubnetRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetSubnetRequest>): GetSubnetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<GetSubnetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubnetRequest): GetSubnetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubnetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.GetSubnetRequest
 */
export const GetSubnetRequest = new GetSubnetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetSubnetResponse$Type extends MessageType<GetSubnetResponse> {
    constructor() {
        super("ipam.GetSubnetResponse", [
            { no: 1, name: "subnet", kind: "message", T: () => Subnet },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<GetSubnetResponse>): GetSubnetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<GetSubnetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetSubnetResponse): GetSubnetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ipam.Subnet subnet */ 1:
                    message.subnet = Subnet.internalBinaryRead(reader, reader.uint32(), options, message.subnet);
                    break;
                case /* ipam.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetSubnetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ipam.Subnet subnet = 1; */
        if (message.subnet)
            Subnet.internalBinaryWrite(message.subnet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ipam.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.GetSubnetResponse
 */
export const GetSubnetResponse = new GetSubnetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateSubnetRequest$Type extends MessageType<UpdateSubnetRequest> {
    constructor() {
        super("ipam.UpdateSubnetRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "cidr", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "description", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 5, name: "location", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 6, name: "location_type", kind: "enum", T: () => ["ipam.LocationType", LocationType] },
            { no: 7, name: "cloud_info", kind: "message", T: () => CloudInfo }
        ]);
    }
    create(value?: PartialMessage<UpdateSubnetRequest>): UpdateSubnetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        message.cidr = "";
        message.name = "";
        message.description = "";
        message.location = "";
        message.locationType = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateSubnetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateSubnetRequest): UpdateSubnetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                case /* string cidr */ 2:
                    message.cidr = reader.string();
                    break;
                case /* string name */ 3:
                    message.name = reader.string();
                    break;
                case /* string description */ 4:
                    message.description = reader.string();
                    break;
                case /* string location */ 5:
                    message.location = reader.string();
                    break;
                case /* ipam.LocationType location_type */ 6:
                    message.locationType = reader.int32();
                    break;
                case /* ipam.CloudInfo cloud_info */ 7:
                    message.cloudInfo = CloudInfo.internalBinaryRead(reader, reader.uint32(), options, message.cloudInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateSubnetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        /* string cidr = 2; */
        if (message.cidr !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.cidr);
        /* string name = 3; */
        if (message.name !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.name);
        /* string description = 4; */
        if (message.description !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.description);
        /* string location = 5; */
        if (message.location !== "")
            writer.tag(5, WireType.LengthDelimited).string(message.location);
        /* ipam.LocationType location_type = 6; */
        if (message.locationType !== 0)
            writer.tag(6, WireType.Varint).int32(message.locationType);
        /* ipam.CloudInfo cloud_info = 7; */
        if (message.cloudInfo)
            CloudInfo.internalBinaryWrite(message.cloudInfo, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.UpdateSubnetRequest
 */
export const UpdateSubnetRequest = new UpdateSubnetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateSubnetResponse$Type extends MessageType<UpdateSubnetResponse> {
    constructor() {
        super("ipam.UpdateSubnetResponse", [
            { no: 1, name: "subnet", kind: "message", T: () => Subnet },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<UpdateSubnetResponse>): UpdateSubnetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<UpdateSubnetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateSubnetResponse): UpdateSubnetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* ipam.Subnet subnet */ 1:
                    message.subnet = Subnet.internalBinaryRead(reader, reader.uint32(), options, message.subnet);
                    break;
                case /* ipam.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateSubnetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* ipam.Subnet subnet = 1; */
        if (message.subnet)
            Subnet.internalBinaryWrite(message.subnet, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* ipam.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.UpdateSubnetResponse
 */
export const UpdateSubnetResponse = new UpdateSubnetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSubnetRequest$Type extends MessageType<DeleteSubnetRequest> {
    constructor() {
        super("ipam.DeleteSubnetRequest", [
            { no: 1, name: "id", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<DeleteSubnetRequest>): DeleteSubnetRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.id = "";
        if (value !== undefined)
            reflectionMergePartial<DeleteSubnetRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSubnetRequest): DeleteSubnetRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string id */ 1:
                    message.id = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSubnetRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string id = 1; */
        if (message.id !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.id);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.DeleteSubnetRequest
 */
export const DeleteSubnetRequest = new DeleteSubnetRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class DeleteSubnetResponse$Type extends MessageType<DeleteSubnetResponse> {
    constructor() {
        super("ipam.DeleteSubnetResponse", [
            { no: 1, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "error", kind: "message", T: () => Error }
        ]);
    }
    create(value?: PartialMessage<DeleteSubnetResponse>): DeleteSubnetResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.success = false;
        if (value !== undefined)
            reflectionMergePartial<DeleteSubnetResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DeleteSubnetResponse): DeleteSubnetResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool success */ 1:
                    message.success = reader.bool();
                    break;
                case /* ipam.Error error */ 2:
                    message.error = Error.internalBinaryRead(reader, reader.uint32(), options, message.error);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DeleteSubnetResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool success = 1; */
        if (message.success !== false)
            writer.tag(1, WireType.Varint).bool(message.success);
        /* ipam.Error error = 2; */
        if (message.error)
            Error.internalBinaryWrite(message.error, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.DeleteSubnetResponse
 */
export const DeleteSubnetResponse = new DeleteSubnetResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class Error$Type extends MessageType<Error> {
    constructor() {
        super("ipam.Error", [
            { no: 1, name: "code", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "details", kind: "map", K: 9 /*ScalarType.STRING*/, V: { kind: "scalar", T: 9 /*ScalarType.STRING*/ } },
            { no: 4, name: "timestamp", kind: "scalar", T: 3 /*ScalarType.INT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<Error>): Error {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = "";
        message.message = "";
        message.details = {};
        message.timestamp = 0n;
        if (value !== undefined)
            reflectionMergePartial<Error>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Error): Error {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string code */ 1:
                    message.code = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* map<string, string> details */ 3:
                    this.binaryReadMap3(message.details, reader, options);
                    break;
                case /* int64 timestamp */ 4:
                    message.timestamp = reader.int64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    private binaryReadMap3(map: Error["details"], reader: IBinaryReader, options: BinaryReadOptions): void {
        let len = reader.uint32(), end = reader.pos + len, key: keyof Error["details"] | undefined, val: Error["details"][any] | undefined;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case 1:
                    key = reader.string();
                    break;
                case 2:
                    val = reader.string();
                    break;
                default: throw new globalThis.Error("unknown map entry field for ipam.Error.details");
            }
        }
        map[key ?? ""] = val ?? "";
    }
    internalBinaryWrite(message: Error, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string code = 1; */
        if (message.code !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.code);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* map<string, string> details = 3; */
        for (let k of globalThis.Object.keys(message.details))
            writer.tag(3, WireType.LengthDelimited).fork().tag(1, WireType.LengthDelimited).string(k).tag(2, WireType.LengthDelimited).string(message.details[k]).join();
        /* int64 timestamp = 4; */
        if (message.timestamp !== 0n)
            writer.tag(4, WireType.Varint).int64(message.timestamp);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ipam.Error
 */
export const Error = new Error$Type();
